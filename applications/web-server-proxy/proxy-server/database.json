{"proxy_admins": [{"email": "admin", "passw": "admin"}], "sites_blocked": [], "private_mode_auth": [], "managers_credentials": [{"email": "admin", "passw": "admin"}], "history": [], "cache": [{"url": "https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html", "last_modified": "Wed, 01 Sep 2004 13:24:52 GMT", "html": "b'<!DOCTYPE html \\n     PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\n     \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n<html xmlns=\\'http://www.w3.org/1999/xhtml\\'>\\n<head><title>HTTP/1.1: Caching in HTTP</title></head>\\n<body><address>part of <a rev=\\'Section\\' href=\\'rfc2616.html\\'>Hypertext Transfer Protocol -- HTTP/1.1</a><br />\\nRFC 2616 Fielding, et al.</address>\\n<h2><a id=\\'sec13\\'>13</a> Caching in HTTP</h2>\\n<p>\\n   HTTP is typically used for distributed information systems, where\\r\\n   performance can be improved by the use of response caches. The\\r\\n   HTTP/1.1 protocol includes a number of elements intended to make\\r\\n   caching work as well as possible. Because these elements are\\r\\n   inextricable from other aspects of the protocol, and because they\\r\\n   interact with each other, it is useful to describe the basic caching\\r\\n   design of HTTP separately from the detailed descriptions of methods,\\r\\n   headers, response codes, etc.\\r\\n</p>\\n<p>\\n   Caching would be useless if it did not significantly improve\\r\\n   performance. The goal of caching in HTTP/1.1 is to eliminate the need\\r\\n   to send requests in many cases, and to eliminate the need to send\\r\\n   full responses in many other cases. The former reduces the number of\\r\\n   network round-trips required for many operations; we use an\\r\\n   \"expiration\" mechanism for this purpose (see section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2\\'>13.2</a>). The\\r\\n   latter reduces network bandwidth requirements; we use a \"validation\"\\r\\n   mechanism for this purpose (see section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.3\\'>13.3</a>).\\r\\n</p>\\n<p>\\n   Requirements for performance, availability, and disconnected\\r\\n   operation require us to be able to relax the goal of semantic\\r\\n   transparency. The HTTP/1.1 protocol allows origin servers, caches,\\r\\n</p>\\n<p>\\n   and clients to explicitly reduce transparency when necessary.\\r\\n   However, because non-transparent operation may confuse non-expert\\r\\n   users, and might be incompatible with certain server applications\\r\\n   (such as those for ordering merchandise), the protocol requires that\\r\\n   transparency be relaxed\\r\\n</p>\\n<pre>      - only by an explicit protocol-level request when relaxed by\\r\\n        client or origin server\\r\\n</pre>\\n<pre>      - only with an explicit warning to the end user when relaxed by\\r\\n        cache or client\\r\\n</pre>\\n<p>\\n   Therefore, the HTTP/1.1 protocol provides these important elements:\\r\\n</p>\\n<pre>      1. Protocol features that provide full semantic transparency when\\r\\n         this is required by all parties.\\r\\n</pre>\\n<pre>      2. Protocol features that allow an origin server or user agent to\\r\\n         explicitly request and control non-transparent operation.\\r\\n</pre>\\n<pre>      3. Protocol features that allow a cache to attach warnings to\\r\\n         responses that do not preserve the requested approximation of\\r\\n         semantic transparency.\\r\\n</pre>\\n<p>\\n   A basic principle is that it must be possible for the clients to\\r\\n   detect any potential relaxation of semantic transparency.\\r\\n</p>\\n<pre>      Note: The server, cache, or client implementor might be faced with\\r\\n      design decisions not explicitly discussed in this specification.\\r\\n      If a decision might affect semantic transparency, the implementor\\r\\n      ought to err on the side of maintaining transparency unless a\\r\\n      careful and complete analysis shows significant benefits in\\r\\n      breaking transparency.\\r\\n</pre>\\n<h3><a id=\\'sec13.1.1\\'>13.1.1</a> Cache Correctness</h3>\\n<p>\\n   A correct cache MUST respond to a request with the most up-to-date\\r\\n   response held by the cache that is appropriate to the request (see\\r\\n   sections <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.5\\'>13.2.5</a>, <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.6\\'>13.2.6</a>, and <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.12\\'>13.12</a>) which meets one of the following\\r\\n   conditions:\\r\\n</p>\\n<pre>      1. It has been checked for equivalence with what the origin server\\r\\n         would have returned by revalidating the response with the\\r\\n         origin server (section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.3\\'>13.3</a>);\\r\\n</pre>\\n<pre>      2. It is \"fresh enough\" (see section 13.2). In the default case,\\r\\n         this means it meets the least restrictive freshness requirement\\r\\n         of the client, origin server, and cache (see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>); if\\r\\n         the origin server so specifies, it is the freshness requirement\\r\\n         of the origin server alone.\\r\\n</pre>\\n<pre>         If a stored response is not \"fresh enough\" by the most\\r\\n         restrictive freshness requirement of both the client and the\\r\\n         origin server, in carefully considered circumstances the cache\\r\\n         MAY still return the response with the appropriate Warning\\r\\n         header (see section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.1.5\\'>13.1.5</a> and <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.46\\'>14.46</a>), unless such a response\\r\\n         is prohibited (e.g., by a \"no-store\" cache-directive, or by a\\r\\n         \"no-cache\" cache-request-directive; see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>).\\r\\n</pre>\\n<pre>      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),\\r\\n         or error (4xx or 5xx) response message.\\r\\n</pre>\\n<p>\\n   If the cache can not communicate with the origin server, then a\\r\\n   correct cache SHOULD respond as above if the response can be\\r\\n   correctly served from the cache; if not it MUST return an error or\\r\\n   warning indicating that there was a communication failure.\\r\\n</p>\\n<p>\\n   If a cache receives a response (either an entire response, or a 304\\r\\n   (Not Modified) response) that it would normally forward to the\\r\\n   requesting client, and the received response is no longer fresh, the\\r\\n   cache SHOULD forward it to the requesting client without adding a new\\r\\n   Warning (but without removing any existing Warning headers). A cache\\r\\n   SHOULD NOT attempt to revalidate a response simply because that\\r\\n   response became stale in transit; this might lead to an infinite\\r\\n   loop. A user agent that receives a stale response without a Warning\\r\\n   MAY display a warning indication to the user.\\r\\n</p>\\n<h3><a id=\\'sec13.1.2\\'>13.1.2</a> Warnings</h3>\\n<p>\\n   Whenever a cache returns a response that is neither first-hand nor\\r\\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\\r\\n   MUST attach a warning to that effect, using a Warning general-header.\\r\\n   The Warning header and the currently defined warnings are described\\r\\n   in section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.46\\'>14.46</a>. The warning allows clients to take appropriate\\r\\n   action.\\r\\n</p>\\n<p>\\n   Warnings MAY be used for other purposes, both cache-related and\\r\\n   otherwise. The use of a warning, rather than an error status code,\\r\\n   distinguish these responses from true failures.\\r\\n</p>\\n<p>\\n   Warnings are assigned three digit warn-codes. The first digit\\r\\n   indicates whether the Warning MUST or MUST NOT be deleted from a\\r\\n   stored cache entry after a successful revalidation:\\r\\n</p>\\n<p>\\n   1xx  Warnings that describe the freshness or revalidation status of\\r\\n     the response, and so MUST be deleted after a successful\\r\\n     revalidation. 1XX warn-codes MAY be generated by a cache only when\\r\\n     validating a cached entry. It MUST NOT be generated by clients.\\r\\n</p>\\n<p>\\n   2xx  Warnings that describe some aspect of the entity body or entity\\r\\n     headers that is not rectified by a revalidation (for example, a\\r\\n     lossy compression of the entity bodies) and which MUST NOT be\\r\\n     deleted after a successful revalidation.\\r\\n</p>\\n<p>\\n   See section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.46\\'>14.46</a> for the definitions of the codes themselves.\\r\\n</p>\\n<p>\\n   HTTP/1.0 caches will cache all Warnings in responses, without\\r\\n   deleting the ones in the first category. Warnings in responses that\\r\\n   are passed to HTTP/1.0 caches carry an extra warning-date field,\\r\\n   which prevents a future HTTP/1.1 recipient from believing an\\r\\n   erroneously cached Warning.\\r\\n</p>\\n<p>\\n   Warnings also carry a warning text. The text MAY be in any\\r\\n   appropriate natural language (perhaps based on the client\\'s Accept\\r\\n   headers), and include an OPTIONAL indication of what character set is\\r\\n   used.\\r\\n</p>\\n<p>\\n   Multiple warnings MAY be attached to a response (either by the origin\\r\\n   server or by a cache), including multiple warnings with the same code\\r\\n   number. For example, a server might provide the same warning with\\r\\n   texts in both English and Basque.\\r\\n</p>\\n<p>\\n   When multiple warnings are attached to a response, it might not be\\r\\n   practical or reasonable to display all of them to the user. This\\r\\n   version of HTTP does not specify strict priority rules for deciding\\r\\n   which warnings to display and in what order, but does suggest some\\r\\n   heuristics.\\r\\n</p>\\n<h3><a id=\\'sec13.1.3\\'>13.1.3</a> Cache-control Mechanisms</h3>\\n<p>\\n   The basic cache mechanisms in HTTP/1.1 (server-specified expiration\\r\\n   times and validators) are implicit directives to caches. In some\\r\\n   cases, a server or client might need to provide explicit directives\\r\\n   to the HTTP caches. We use the Cache-Control header for this purpose.\\r\\n</p>\\n<p>\\n   The Cache-Control header allows a client or server to transmit a\\r\\n   variety of directives in either requests or responses. These\\r\\n   directives typically override the default caching algorithms. As a\\r\\n   general rule, if there is any apparent conflict between header\\r\\n   values, the most restrictive interpretation is applied (that is, the\\r\\n   one that is most likely to preserve semantic transparency). However,\\r\\n</p>\\n<p>\\n   in some cases, cache-control directives are explicitly specified as\\r\\n   weakening the approximation of semantic transparency (for example,\\r\\n   \"max-stale\" or \"public\").\\r\\n</p>\\n<p>\\n   The cache-control directives are described in detail in section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>.\\r\\n</p>\\n<h3><a id=\\'sec13.1.4\\'>13.1.4</a> Explicit User Agent Warnings</h3>\\n<p>\\n   Many user agents make it possible for users to override the basic\\r\\n   caching mechanisms. For example, the user agent might allow the user\\r\\n   to specify that cached entities (even explicitly stale ones) are\\r\\n   never validated. Or the user agent might habitually add \"Cache-\\r\\n   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\\r\\n   default to either non-transparent behavior, or behavior that results\\r\\n   in abnormally ineffective caching, but MAY be explicitly configured\\r\\n   to do so by an explicit action of the user.\\r\\n</p>\\n<p>\\n   If the user has overridden the basic caching mechanisms, the user\\r\\n   agent SHOULD explicitly indicate to the user whenever this results in\\r\\n   the display of information that might not meet the server\\'s\\r\\n   transparency requirements (in particular, if the displayed entity is\\r\\n   known to be stale). Since the protocol normally allows the user agent\\r\\n   to determine if responses are stale or not, this indication need only\\r\\n   be displayed when this actually happens. The indication need not be a\\r\\n   dialog box; it could be an icon (for example, a picture of a rotting\\r\\n   fish) or some other indicator.\\r\\n</p>\\n<p>\\n   If the user has overridden the caching mechanisms in a way that would\\r\\n   abnormally reduce the effectiveness of caches, the user agent SHOULD\\r\\n   continually indicate this state to the user (for example, by a\\r\\n   display of a picture of currency in flames) so that the user does not\\r\\n   inadvertently consume excess resources or suffer from excessive\\r\\n   latency.\\r\\n</p>\\n<h3><a id=\\'sec13.1.5\\'>13.1.5</a> Exceptions to the Rules and Warnings</h3>\\n<p>\\n   In some cases, the operator of a cache MAY choose to configure it to\\r\\n   return stale responses even when not requested by clients. This\\r\\n   decision ought not be made lightly, but may be necessary for reasons\\r\\n   of availability or performance, especially when the cache is poorly\\r\\n   connected to the origin server. Whenever a cache returns a stale\\r\\n   response, it MUST mark it as such (using a Warning header) enabling\\r\\n   the client software to alert the user that there might be a potential\\r\\n   problem.\\r\\n</p>\\n<p>\\n   It also allows the user agent to take steps to obtain a first-hand or\\r\\n   fresh response. For this reason, a cache SHOULD NOT return a stale\\r\\n   response if the client explicitly requests a first-hand or fresh one,\\r\\n   unless it is impossible to comply for technical or policy reasons.\\r\\n</p>\\n<h3><a id=\\'sec13.1.6\\'>13.1.6</a> Client-controlled Behavior</h3>\\n<p>\\n   While the origin server (and to a lesser extent, intermediate caches,\\r\\n   by their contribution to the age of a response) are the primary\\r\\n   source of expiration information, in some cases the client might need\\r\\n   to control a cache\\'s decision about whether to return a cached\\r\\n   response without validating it. Clients do this using several\\r\\n   directives of the Cache-Control header.\\r\\n</p>\\n<p>\\n   A client\\'s request MAY specify the maximum age it is willing to\\r\\n   accept of an unvalidated response; specifying a value of zero forces\\r\\n   the cache(s) to revalidate all responses. A client MAY also specify\\r\\n   the minimum time remaining before a response expires. Both of these\\r\\n   options increase constraints on the behavior of caches, and so cannot\\r\\n   further relax the cache\\'s approximation of semantic transparency.\\r\\n</p>\\n<p>\\n   A client MAY also specify that it will accept stale responses, up to\\r\\n   some maximum amount of staleness. This loosens the constraints on the\\r\\n   caches, and so might violate the origin server\\'s specified\\r\\n   constraints on semantic transparency, but might be necessary to\\r\\n   support disconnected operation, or high availability in the face of\\r\\n   poor connectivity.\\r\\n</p>\\n<h3><a id=\\'sec13.2\\'>13.2</a> Expiration Model</h3>\\n<h3><a id=\\'sec13.2.1\\'>13.2.1</a> Server-Specified Expiration</h3>\\n<p>\\n   HTTP caching works best when caches can entirely avoid making\\r\\n   requests to the origin server. The primary mechanism for avoiding\\r\\n   requests is for an origin server to provide an explicit expiration\\r\\n   time in the future, indicating that a response MAY be used to satisfy\\r\\n   subsequent requests. In other words, a cache can return a fresh\\r\\n   response without first contacting the server.\\r\\n</p>\\n<p>\\n   Our expectation is that servers will assign future explicit\\r\\n   expiration times to responses in the belief that the entity is not\\r\\n   likely to change, in a semantically significant way, before the\\r\\n   expiration time is reached. This normally preserves semantic\\r\\n   transparency, as long as the server\\'s expiration times are carefully\\r\\n   chosen.\\r\\n</p>\\n<p>\\n   The expiration mechanism applies only to responses taken from a cache\\r\\n   and not to first-hand responses forwarded immediately to the\\r\\n   requesting client.\\r\\n</p>\\n<p>\\n   If an origin server wishes to force a semantically transparent cache\\r\\n   to validate every request, it MAY assign an explicit expiration time\\r\\n   in the past. This means that the response is always stale, and so the\\r\\n   cache SHOULD validate it before using it for subsequent requests. See\\r\\n   section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9.4\\'>14.9.4</a> for a more restrictive way to force revalidation.\\r\\n</p>\\n<p>\\n   If an origin server wishes to force any HTTP/1.1 cache, no matter how\\r\\n   it is configured, to validate every request, it SHOULD use the \"must-\\r\\n   revalidate\" cache-control directive (see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>).\\r\\n</p>\\n<p>\\n   Servers specify explicit expiration times using either the Expires\\r\\n   header, or the max-age directive of the Cache-Control header.\\r\\n</p>\\n<p>\\n   An expiration time cannot be used to force a user agent to refresh\\r\\n   its display or reload a resource; its semantics apply only to caching\\r\\n   mechanisms, and such mechanisms need only check a resource\\'s\\r\\n   expiration status when a new request for that resource is initiated.\\r\\n   See section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.13\\'>13.13</a> for an explanation of the difference between caches\\r\\n   and history mechanisms.\\r\\n</p>\\n<h3><a id=\\'sec13.2.2\\'>13.2.2</a> Heuristic Expiration</h3>\\n<p>\\n   Since origin servers do not always provide explicit expiration times,\\r\\n   HTTP caches typically assign heuristic expiration times, employing\\r\\n   algorithms that use other header values (such as the Last-Modified\\r\\n   time) to estimate a plausible expiration time. The HTTP/1.1\\r\\n   specification does not provide specific algorithms, but does impose\\r\\n   worst-case constraints on their results. Since heuristic expiration\\r\\n   times might compromise semantic transparency, they ought to used\\r\\n   cautiously, and we encourage origin servers to provide explicit\\r\\n   expiration times as much as possible.\\r\\n</p>\\n<h3><a id=\\'sec13.2.3\\'>13.2.3</a> Age Calculations</h3>\\n<p>\\n   In order to know if a cached entry is fresh, a cache needs to know if\\r\\n   its age exceeds its freshness lifetime. We discuss how to calculate\\r\\n   the latter in section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.4\\'>13.2.4</a>; this section describes how to calculate\\r\\n   the age of a response or cache entry.\\r\\n</p>\\n<p>\\n   In this discussion, we use the term \"now\" to mean \"the current value\\r\\n   of the clock at the host performing the calculation.\" Hosts that use\\r\\n   HTTP, but especially hosts running origin servers and caches, SHOULD\\r\\n   use NTP <a rel=\\'bibref\\' href=\\'rfc2616-sec17.html#bib28\\'>[28]</a> or some similar protocol to synchronize their clocks to\\r\\n   a globally accurate time standard.\\r\\n</p>\\n<p>\\n   HTTP/1.1 requires origin servers to send a Date header, if possible,\\r\\n   with every response, giving the time at which the response was\\r\\n   generated (see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.18\\'>14.18</a>). We use the term \"date_value\" to denote\\r\\n   the value of the Date header, in a form appropriate for arithmetic\\r\\n   operations.\\r\\n</p>\\n<p>\\n   HTTP/1.1 uses the Age response-header to convey the estimated age of\\r\\n   the response message when obtained from a cache. The Age field value\\r\\n   is the cache\\'s estimate of the amount of time since the response was\\r\\n   generated or revalidated by the origin server.\\r\\n</p>\\n<p>\\n   In essence, the Age value is the sum of the time that the response\\r\\n   has been resident in each of the caches along the path from the\\r\\n   origin server, plus the amount of time it has been in transit along\\r\\n   network paths.\\r\\n</p>\\n<p>\\n   We use the term \"age_value\" to denote the value of the Age header, in\\r\\n   a form appropriate for arithmetic operations.\\r\\n</p>\\n<p>\\n   A response\\'s age can be calculated in two entirely independent ways:\\r\\n</p>\\n<pre>      1. now minus date_value, if the local clock is reasonably well\\r\\n         synchronized to the origin server\\'s clock. If the result is\\r\\n         negative, the result is replaced by zero.\\r\\n</pre>\\n<pre>      2. age_value, if all of the caches along the response path\\r\\n         implement HTTP/1.1.\\r\\n</pre>\\n<p>\\n   Given that we have two independent ways to compute the age of a\\r\\n   response when it is received, we can combine these as\\r\\n</p>\\n<pre>       corrected_received_age = max(now - date_value, age_value)\\r\\n</pre>\\n<p>\\n   and as long as we have either nearly synchronized clocks or all-\\r\\n   HTTP/1.1 paths, one gets a reliable (conservative) result.\\r\\n</p>\\n<p>\\n   Because of network-imposed delays, some significant interval might\\r\\n   pass between the time that a server generates a response and the time\\r\\n   it is received at the next outbound cache or client. If uncorrected,\\r\\n   this delay could result in improperly low ages.\\r\\n</p>\\n<p>\\n   Because the request that resulted in the returned Age value must have\\r\\n   been initiated prior to that Age value\\'s generation, we can correct\\r\\n   for delays imposed by the network by recording the time at which the\\r\\n   request was initiated. Then, when an Age value is received, it MUST\\r\\n   be interpreted relative to the time the request was initiated, not\\r\\n</p>\\n<p>\\n   the time that the response was received. This algorithm results in\\r\\n   conservative behavior no matter how much delay is experienced. So, we\\r\\n   compute:\\r\\n</p>\\n<pre>      corrected_initial_age = corrected_received_age\\r\\n                            + (now - request_time)\\r\\n</pre>\\n<p>\\n   where \"request_time\" is the time (according to the local clock) when\\r\\n   the request that elicited this response was sent.\\r\\n</p>\\n<p>\\n   Summary of age calculation algorithm, when a cache receives a\\r\\n   response:\\r\\n</p>\\n<pre>      /*\\r\\n       * age_value\\r\\n       *      is the value of Age: header received by the cache with\\r\\n       *              this response.\\r\\n       * date_value\\r\\n       *      is the value of the origin server\\'s Date: header\\r\\n       * request_time\\r\\n       *      is the (local) time when the cache made the request\\r\\n       *              that resulted in this cached response\\r\\n       * response_time\\r\\n       *      is the (local) time when the cache received the\\r\\n       *              response\\r\\n       * now\\r\\n       *      is the current (local) time\\r\\n       */\\r\\n</pre>\\n<pre>      apparent_age = max(0, response_time - date_value);\\r\\n      corrected_received_age = max(apparent_age, age_value);\\r\\n      response_delay = response_time - request_time;\\r\\n      corrected_initial_age = corrected_received_age + response_delay;\\r\\n      resident_time = now - response_time;\\r\\n      current_age   = corrected_initial_age + resident_time;\\r\\n</pre>\\n<p>\\n   The current_age of a cache entry is calculated by adding the amount\\r\\n   of time (in seconds) since the cache entry was last validated by the\\r\\n   origin server to the corrected_initial_age. When a response is\\r\\n   generated from a cache entry, the cache MUST include a single Age\\r\\n   header field in the response with a value equal to the cache entry\\'s\\r\\n   current_age.\\r\\n</p>\\n<p>\\n   The presence of an Age header field in a response implies that a\\r\\n   response is not first-hand. However, the converse is not true, since\\r\\n   the lack of an Age header field in a response does not imply that the\\r\\n</p>\\n<p>\\n   response is first-hand unless all caches along the request path are\\r\\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\\r\\n   the Age header field).\\r\\n</p>\\n<h3><a id=\\'sec13.2.4\\'>13.2.4</a> Expiration Calculations</h3>\\n<p>\\n   In order to decide whether a response is fresh or stale, we need to\\r\\n   compare its freshness lifetime to its age. The age is calculated as\\r\\n   described in section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.3\\'>13.2.3</a>; this section describes how to calculate\\r\\n   the freshness lifetime, and to determine if a response has expired.\\r\\n   In the discussion below, the values can be represented in any form\\r\\n   appropriate for arithmetic operations.\\r\\n</p>\\n<p>\\n   We use the term \"expires_value\" to denote the value of the Expires\\r\\n   header. We use the term \"max_age_value\" to denote an appropriate\\r\\n   value of the number of seconds carried by the \"max-age\" directive of\\r\\n   the Cache-Control header in a response (see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9.3\\'>14.9.3</a>).\\r\\n</p>\\n<p>\\n   The max-age directive takes priority over Expires, so if max-age is\\r\\n   present in a response, the calculation is simply:\\r\\n</p>\\n<pre>      freshness_lifetime = max_age_value\\r\\n</pre>\\n<p>\\n   Otherwise, if Expires is present in the response, the calculation is:\\r\\n</p>\\n<pre>      freshness_lifetime = expires_value - date_value\\r\\n</pre>\\n<p>\\n   Note that neither of these calculations is vulnerable to clock skew,\\r\\n   since all of the information comes from the origin server.\\r\\n</p>\\n<p>\\n   If none of Expires, Cache-Control: max-age, or Cache-Control: s-\\r\\n   maxage (see section 14.9.3) appears in the response, and the response\\r\\n   does not include other restrictions on caching, the cache MAY compute\\r\\n   a freshness lifetime using a heuristic. The cache MUST attach Warning\\r\\n   113 to any response whose age is more than 24 hours if such warning\\r\\n   has not already been added.\\r\\n</p>\\n<p>\\n   Also, if the response does have a Last-Modified time, the heuristic\\r\\n   expiration value SHOULD be no more than some fraction of the interval\\r\\n   since that time. A typical setting of this fraction might be 10%.\\r\\n</p>\\n<p>\\n   The calculation to determine if a response has expired is quite\\r\\n   simple:\\r\\n</p>\\n<pre>      response_is_fresh = (freshness_lifetime > current_age)\\r\\n</pre>\\n<h3><a id=\\'sec13.2.5\\'>13.2.5</a> Disambiguating Expiration Values</h3>\\n<p>\\n   Because expiration values are assigned optimistically, it is possible\\r\\n   for two caches to contain fresh values for the same resource that are\\r\\n   different.\\r\\n</p>\\n<p>\\n   If a client performing a retrieval receives a non-first-hand response\\r\\n   for a request that was already fresh in its own cache, and the Date\\r\\n   header in its existing cache entry is newer than the Date on the new\\r\\n   response, then the client MAY ignore the response. If so, it MAY\\r\\n   retry the request with a \"Cache-Control: max-age=0\" directive (see\\r\\n   section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>), to force a check with the origin server.\\r\\n</p>\\n<p>\\n   If a cache has two fresh responses for the same representation with\\r\\n   different validators, it MUST use the one with the more recent Date\\r\\n   header. This situation might arise because the cache is pooling\\r\\n   responses from other caches, or because a client has asked for a\\r\\n   reload or a revalidation of an apparently fresh cache entry.\\r\\n</p>\\n<h3><a id=\\'sec13.2.6\\'>13.2.6</a> Disambiguating Multiple Responses</h3>\\n<p>\\n   Because a client might be receiving responses via multiple paths, so\\r\\n   that some responses flow through one set of caches and other\\r\\n   responses flow through a different set of caches, a client might\\r\\n   receive responses in an order different from that in which the origin\\r\\n   server sent them. We would like the client to use the most recently\\r\\n   generated response, even if older responses are still apparently\\r\\n   fresh.\\r\\n</p>\\n<p>\\n   Neither the entity tag nor the expiration value can impose an\\r\\n   ordering on responses, since it is possible that a later response\\r\\n   intentionally carries an earlier expiration time. The Date values are\\r\\n   ordered to a granularity of one second.\\r\\n</p>\\n<p>\\n   When a client tries to revalidate a cache entry, and the response it\\r\\n   receives contains a Date header that appears to be older than the one\\r\\n   for the existing entry, then the client SHOULD repeat the request\\r\\n   unconditionally, and include\\r\\n</p>\\n<pre>       Cache-Control: max-age=0\\r\\n</pre>\\n<p>\\n   to force any intermediate caches to validate their copies directly\\r\\n   with the origin server, or\\r\\n</p>\\n<pre>       Cache-Control: no-cache\\r\\n</pre>\\n<p>\\n   to force any intermediate caches to obtain a new copy from the origin\\r\\n   server.\\r\\n</p>\\n<p>\\n   If the Date values are equal, then the client MAY use either response\\r\\n   (or MAY, if it is being extremely prudent, request a new response).\\r\\n   Servers MUST NOT depend on clients being able to choose\\r\\n   deterministically between responses generated during the same second,\\r\\n   if their expiration times overlap.\\r\\n</p>\\n<h3><a id=\\'sec13.3\\'>13.3</a> Validation Model</h3>\\n<p>\\n   When a cache has a stale entry that it would like to use as a\\r\\n   response to a client\\'s request, it first has to check with the origin\\r\\n   server (or possibly an intermediate cache with a fresh response) to\\r\\n   see if its cached entry is still usable. We call this \"validating\"\\r\\n   the cache entry. Since we do not want to have to pay the overhead of\\r\\n   retransmitting the full response if the cached entry is good, and we\\r\\n   do not want to pay the overhead of an extra round trip if the cached\\r\\n   entry is invalid, the HTTP/1.1 protocol supports the use of\\r\\n   conditional methods.\\r\\n</p>\\n<p>\\n   The key protocol features for supporting conditional methods are\\r\\n   those concerned with \"cache validators.\" When an origin server\\r\\n   generates a full response, it attaches some sort of validator to it,\\r\\n   which is kept with the cache entry. When a client (user agent or\\r\\n   proxy cache) makes a conditional request for a resource for which it\\r\\n   has a cache entry, it includes the associated validator in the\\r\\n   request.\\r\\n</p>\\n<p>\\n   The server then checks that validator against the current validator\\r\\n   for the entity, and, if they match (see section 13.3.3), it responds\\r\\n   with a special status code (usually, 304 (Not Modified)) and no\\r\\n   entity-body. Otherwise, it returns a full response (including\\r\\n   entity-body). Thus, we avoid transmitting the full response if the\\r\\n   validator matches, and we avoid an extra round trip if it does not\\r\\n   match.\\r\\n</p>\\n<p>\\n   In HTTP/1.1, a conditional request looks exactly the same as a normal\\r\\n   request for the same resource, except that it carries a special\\r\\n   header (which includes the validator) that implicitly turns the\\r\\n   method (usually, GET) into a conditional.\\r\\n</p>\\n<p>\\n   The protocol includes both positive and negative senses of cache-\\r\\n   validating conditions. That is, it is possible to request either that\\r\\n   a method be performed if and only if a validator matches or if and\\r\\n   only if no validators match.\\r\\n</p>\\n<pre>      Note: a response that lacks a validator may still be cached, and\\r\\n      served from cache until it expires, unless this is explicitly\\r\\n      prohibited by a cache-control directive. However, a cache cannot\\r\\n      do a conditional retrieval if it does not have a validator for the\\r\\n      entity, which means it will not be refreshable after it expires.\\r\\n</pre>\\n<h3><a id=\\'sec13.3.1\\'>13.3.1</a> Last-Modified Dates</h3>\\n<p>\\n   The Last-Modified entity-header field value is often used as a cache\\r\\n   validator. In simple terms, a cache entry is considered to be valid\\r\\n   if the entity has not been modified since the Last-Modified value.\\r\\n</p>\\n<h3><a id=\\'sec13.3.2\\'>13.3.2</a> Entity Tag Cache Validators</h3>\\n<p>\\n   The ETag response-header field value, an entity tag, provides for an\\r\\n   \"opaque\" cache validator. This might allow more reliable validation\\r\\n   in situations where it is inconvenient to store modification dates,\\r\\n   where the one-second resolution of HTTP date values is not\\r\\n   sufficient, or where the origin server wishes to avoid certain\\r\\n   paradoxes that might arise from the use of modification dates.\\r\\n</p>\\n<p>\\n   Entity Tags are described in section <a rel=\\'xref\\' href=\\'rfc2616-sec3.html#sec3.11\\'>3.11</a>. The headers used with\\r\\n   entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.\\r\\n</p>\\n<h3><a id=\\'sec13.3.3\\'>13.3.3</a> Weak and Strong Validators</h3>\\n<p>\\n   Since both origin servers and caches will compare two validators to\\r\\n   decide if they represent the same or different entities, one normally\\r\\n   would expect that if the entity (the entity-body or any entity-\\r\\n   headers) changes in any way, then the associated validator would\\r\\n   change as well. If this is true, then we call this validator a\\r\\n   \"strong validator.\"\\r\\n</p>\\n<p>\\n   However, there might be cases when a server prefers to change the\\r\\n   validator only on semantically significant changes, and not when\\r\\n   insignificant aspects of the entity change. A validator that does not\\r\\n   always change when the resource changes is a \"weak validator.\"\\r\\n</p>\\n<p>\\n   Entity tags are normally \"strong validators,\" but the protocol\\r\\n   provides a mechanism to tag an entity tag as \"weak.\" One can think of\\r\\n   a strong validator as one that changes whenever the bits of an entity\\r\\n   changes, while a weak value changes whenever the meaning of an entity\\r\\n   changes. Alternatively, one can think of a strong validator as part\\r\\n   of an identifier for a specific entity, while a weak validator is\\r\\n   part of an identifier for a set of semantically equivalent entities.\\r\\n</p>\\n<pre>      Note: One example of a strong validator is an integer that is\\r\\n      incremented in stable storage every time an entity is changed.\\r\\n</pre>\\n<pre>      An entity\\'s modification time, if represented with one-second\\r\\n      resolution, could be a weak validator, since it is possible that\\r\\n      the resource might be modified twice during a single second.\\r\\n</pre>\\n<pre>      Support for weak validators is optional. However, weak validators\\r\\n      allow for more efficient caching of equivalent objects; for\\r\\n      example, a hit counter on a site is probably good enough if it is\\r\\n      updated every few days or weeks, and any value during that period\\r\\n      is likely \"good enough\" to be equivalent.\\r\\n</pre>\\n<p>\\n   A \"use\" of a validator is either when a client generates a request\\r\\n   and includes the validator in a validating header field, or when a\\r\\n   server compares two validators.\\r\\n</p>\\n<p>\\n   Strong validators are usable in any context. Weak validators are only\\r\\n   usable in contexts that do not depend on exact equality of an entity.\\r\\n   For example, either kind is usable for a conditional GET of a full\\r\\n   entity. However, only a strong validator is usable for a sub-range\\r\\n   retrieval, since otherwise the client might end up with an internally\\r\\n   inconsistent entity.\\r\\n</p>\\n<p>\\n   Clients MAY issue simple (non-subrange) GET requests with either weak\\r\\n   validators or strong validators. Clients MUST NOT use weak validators\\r\\n   in other forms of request.\\r\\n</p>\\n<p>\\n   The only function that the HTTP/1.1 protocol defines on validators is\\r\\n   comparison. There are two validator comparison functions, depending\\r\\n   on whether the comparison context allows the use of weak validators\\r\\n   or not:\\r\\n</p>\\n<pre>      - The strong comparison function: in order to be considered equal,\\r\\n        both validators MUST be identical in every way, and both MUST\\r\\n        NOT be weak.\\r\\n</pre>\\n<pre>      - The weak comparison function: in order to be considered equal,\\r\\n        both validators MUST be identical in every way, but either or\\r\\n        both of them MAY be tagged as \"weak\" without affecting the\\r\\n        result.\\r\\n</pre>\\n<p>\\n   An entity tag is strong unless it is explicitly tagged as weak.\\r\\n   Section 3.11 gives the syntax for entity tags.\\r\\n</p>\\n<p>\\n   A Last-Modified time, when used as a validator in a request, is\\r\\n   implicitly weak unless it is possible to deduce that it is strong,\\r\\n   using the following rules:\\r\\n</p>\\n<pre>      - The validator is being compared by an origin server to the\\r\\n        actual current validator for the entity and,\\r\\n</pre>\\n<pre>      - That origin server reliably knows that the associated entity did\\r\\n        not change twice during the second covered by the presented\\r\\n        validator.\\r\\n</pre>\\n<p>\\n   or\\r\\n</p>\\n<pre>      - The validator is about to be used by a client in an If-\\r\\n        Modified-Since or If-Unmodified-Since header, because the client\\r\\n        has a cache entry for the associated entity, and\\r\\n</pre>\\n<pre>      - That cache entry includes a Date value, which gives the time\\r\\n        when the origin server sent the original response, and\\r\\n</pre>\\n<pre>      - The presented Last-Modified time is at least 60 seconds before\\r\\n        the Date value.\\r\\n</pre>\\n<p>\\n   or\\r\\n</p>\\n<pre>      - The validator is being compared by an intermediate cache to the\\r\\n        validator stored in its cache entry for the entity, and\\r\\n</pre>\\n<pre>      - That cache entry includes a Date value, which gives the time\\r\\n        when the origin server sent the original response, and\\r\\n</pre>\\n<pre>      - The presented Last-Modified time is at least 60 seconds before\\r\\n        the Date value.\\r\\n</pre>\\n<p>\\n   This method relies on the fact that if two different responses were\\r\\n   sent by the origin server during the same second, but both had the\\r\\n   same Last-Modified time, then at least one of those responses would\\r\\n   have a Date value equal to its Last-Modified time. The arbitrary 60-\\r\\n   second limit guards against the possibility that the Date and Last-\\r\\n   Modified values are generated from different clocks, or at somewhat\\r\\n   different times during the preparation of the response. An\\r\\n   implementation MAY use a value larger than 60 seconds, if it is\\r\\n   believed that 60 seconds is too short.\\r\\n</p>\\n<p>\\n   If a client wishes to perform a sub-range retrieval on a value for\\r\\n   which it has only a Last-Modified time and no opaque validator, it\\r\\n   MAY do this only if the Last-Modified time is strong in the sense\\r\\n   described here.\\r\\n</p>\\n<p>\\n   A cache or origin server receiving a conditional request, other than\\r\\n   a full-body GET request, MUST use the strong comparison function to\\r\\n   evaluate the condition.\\r\\n</p>\\n<p>\\n   These rules allow HTTP/1.1 caches and clients to safely perform sub-\\r\\n   range retrievals on values that have been obtained from HTTP/1.0\\r\\n</p>\\n<p>\\n   servers.\\r\\n</p>\\n<h3><a id=\\'sec13.3.4\\'>13.3.4</a> Rules for When to Use Entity Tags and Last-Modified Dates</h3>\\n<p>\\n   We adopt a set of rules and recommendations for origin servers,\\r\\n   clients, and caches regarding when various validator types ought to\\r\\n   be used, and for what purposes.\\r\\n</p>\\n<p>\\n   HTTP/1.1 origin servers:\\r\\n</p>\\n<pre>      - SHOULD send an entity tag validator unless it is not feasible to\\r\\n        generate one.\\r\\n</pre>\\n<pre>      - MAY send a weak entity tag instead of a strong entity tag, if\\r\\n        performance considerations support the use of weak entity tags,\\r\\n        or if it is unfeasible to send a strong entity tag.\\r\\n</pre>\\n<pre>      - SHOULD send a Last-Modified value if it is feasible to send one,\\r\\n        unless the risk of a breakdown in semantic transparency that\\r\\n        could result from using this date in an If-Modified-Since header\\r\\n        would lead to serious problems.\\r\\n</pre>\\n<p>\\n   In other words, the preferred behavior for an HTTP/1.1 origin server\\r\\n   is to send both a strong entity tag and a Last-Modified value.\\r\\n</p>\\n<p>\\n   In order to be legal, a strong entity tag MUST change whenever the\\r\\n   associated entity value changes in any way. A weak entity tag SHOULD\\r\\n   change whenever the associated entity changes in a semantically\\r\\n   significant way.\\r\\n</p>\\n<pre>      Note: in order to provide semantically transparent caching, an\\r\\n      origin server must avoid reusing a specific strong entity tag\\r\\n      value for two different entities, or reusing a specific weak\\r\\n      entity tag value for two semantically different entities. Cache\\r\\n      entries might persist for arbitrarily long periods, regardless of\\r\\n      expiration times, so it might be inappropriate to expect that a\\r\\n      cache will never again attempt to validate an entry using a\\r\\n      validator that it obtained at some point in the past.\\r\\n</pre>\\n<p>\\n   HTTP/1.1 clients:\\r\\n</p>\\n<pre>      - If an entity tag has been provided by the origin server, MUST\\r\\n        use that entity tag in any cache-conditional request (using If-\\r\\n        Match or If-None-Match).\\r\\n</pre>\\n<pre>      - If only a Last-Modified value has been provided by the origin\\r\\n        server, SHOULD use that value in non-subrange cache-conditional\\r\\n        requests (using If-Modified-Since).\\r\\n</pre>\\n<pre>      - If only a Last-Modified value has been provided by an HTTP/1.0\\r\\n        origin server, MAY use that value in subrange cache-conditional\\r\\n        requests (using If-Unmodified-Since:). The user agent SHOULD\\r\\n        provide a way to disable this, in case of difficulty.\\r\\n</pre>\\n<pre>      - If both an entity tag and a Last-Modified value have been\\r\\n        provided by the origin server, SHOULD use both validators in\\r\\n        cache-conditional requests. This allows both HTTP/1.0 and\\r\\n        HTTP/1.1 caches to respond appropriately.\\r\\n</pre>\\n<p>\\n   An HTTP/1.1 origin server, upon receiving a conditional request that\\r\\n   includes both a Last-Modified date (e.g., in an If-Modified-Since or\\r\\n   If-Unmodified-Since header field) and one or more entity tags (e.g.,\\r\\n   in an If-Match, If-None-Match, or If-Range header field) as cache\\r\\n   validators, MUST NOT return a response status of 304 (Not Modified)\\r\\n   unless doing so is consistent with all of the conditional header\\r\\n   fields in the request.\\r\\n</p>\\n<p>\\n   An HTTP/1.1 caching proxy, upon receiving a conditional request that\\r\\n   includes both a Last-Modified date and one or more entity tags as\\r\\n   cache validators, MUST NOT return a locally cached response to the\\r\\n   client unless that cached response is consistent with all of the\\r\\n   conditional header fields in the request.\\r\\n</p>\\n<pre>      Note: The general principle behind these rules is that HTTP/1.1\\r\\n      servers and clients should transmit as much non-redundant\\r\\n      information as is available in their responses and requests.\\r\\n      HTTP/1.1 systems receiving this information will make the most\\r\\n      conservative assumptions about the validators they receive.\\r\\n</pre>\\n<pre>      HTTP/1.0 clients and caches will ignore entity tags. Generally,\\r\\n      last-modified values received or used by these systems will\\r\\n      support transparent and efficient caching, and so HTTP/1.1 origin\\r\\n      servers should provide Last-Modified values. In those rare cases\\r\\n      where the use of a Last-Modified value as a validator by an\\r\\n      HTTP/1.0 system could result in a serious problem, then HTTP/1.1\\r\\n      origin servers should not provide one.\\r\\n</pre>\\n<h3><a id=\\'sec13.3.5\\'>13.3.5</a> Non-validating Conditionals</h3>\\n<p>\\n   The principle behind entity tags is that only the service author\\r\\n   knows the semantics of a resource well enough to select an\\r\\n   appropriate cache validation mechanism, and the specification of any\\r\\n   validator comparison function more complex than byte-equality would\\r\\n   open up a can of worms. Thus, comparisons of any other headers\\r\\n   (except Last-Modified, for compatibility with HTTP/1.0) are never\\r\\n   used for purposes of validating a cache entry.\\r\\n</p>\\n<h3><a id=\\'sec13.4\\'>13.4</a> Response Cacheability</h3>\\n<p>\\n   Unless specifically constrained by a cache-control (section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>)\\r\\n   directive, a caching system MAY always store a successful response\\r\\n   (see section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.8\\'>13.8</a>) as a cache entry, MAY return it without validation\\r\\n   if it is fresh, and MAY return it after successful validation. If\\r\\n   there is neither a cache validator nor an explicit expiration time\\r\\n   associated with a response, we do not expect it to be cached, but\\r\\n   certain caches MAY violate this expectation (for example, when little\\r\\n   or no network connectivity is available). A client can usually detect\\r\\n   that such a response was taken from a cache by comparing the Date\\r\\n   header to the current time.\\r\\n</p>\\n<pre>      Note: some HTTP/1.0 caches are known to violate this expectation\\r\\n      without providing any Warning.\\r\\n</pre>\\n<p>\\n   However, in some cases it might be inappropriate for a cache to\\r\\n   retain an entity, or to return it in response to a subsequent\\r\\n   request. This might be because absolute semantic transparency is\\r\\n   deemed necessary by the service author, or because of security or\\r\\n   privacy considerations. Certain cache-control directives are\\r\\n   therefore provided so that the server can indicate that certain\\r\\n   resource entities, or portions thereof, are not to be cached\\r\\n   regardless of other considerations.\\r\\n</p>\\n<p>\\n   Note that section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.8\\'>14.8</a> normally prevents a shared cache from saving\\r\\n   and returning a response to a previous request if that request\\r\\n   included an Authorization header.\\r\\n</p>\\n<p>\\n   A response received with a status code of 200, 203, 206, 300, 301 or\\r\\n   410 MAY be stored by a cache and used in reply to a subsequent\\r\\n   request, subject to the expiration mechanism, unless a cache-control\\r\\n   directive prohibits caching. However, a cache that does not support\\r\\n   the Range and Content-Range headers MUST NOT cache 206 (Partial\\r\\n   Content) responses.\\r\\n</p>\\n<p>\\n   A response received with any other status code (e.g. status codes 302\\r\\n   and 307) MUST NOT be returned in a reply to a subsequent request\\r\\n   unless there are cache-control directives or another header(s) that\\r\\n   explicitly allow it. For example, these include the following: an\\r\\n   Expires header (section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.21\\'>14.21</a>); a \"max-age\", \"s-maxage\",  \"must-\\r\\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\\r\\n   directive (section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>).\\r\\n</p>\\n<h3><a id=\\'sec13.5\\'>13.5</a> Constructing Responses From Caches</h3>\\n<p>\\n   The purpose of an HTTP cache is to store information received in\\r\\n   response to requests for use in responding to future requests. In\\r\\n   many cases, a cache simply returns the appropriate parts of a\\r\\n   response to the requester. However, if the cache holds a cache entry\\r\\n   based on a previous response, it might have to combine parts of a new\\r\\n   response with what is held in the cache entry.\\r\\n</p>\\n<h3><a id=\\'sec13.5.1\\'>13.5.1</a> End-to-end and Hop-by-hop Headers</h3>\\n<p>\\n   For the purpose of defining the behavior of caches and non-caching\\r\\n   proxies, we divide HTTP headers into two categories:\\r\\n</p>\\n<pre>      - End-to-end headers, which are  transmitted to the ultimate\\r\\n        recipient of a request or response. End-to-end headers in\\r\\n        responses MUST be stored as part of a cache entry and MUST be\\r\\n        transmitted in any response formed from a cache entry.\\r\\n</pre>\\n<pre>      - Hop-by-hop headers, which are meaningful only for a single\\r\\n        transport-level connection, and are not stored by caches or\\r\\n        forwarded by proxies.\\r\\n</pre>\\n<p>\\n   The following HTTP/1.1 headers are hop-by-hop headers:\\r\\n</p>\\n<pre>      - Connection\\r\\n      - Keep-Alive\\r\\n      - Proxy-Authenticate\\r\\n      - Proxy-Authorization\\r\\n      - TE\\r\\n      - Trailers\\r\\n      - Transfer-Encoding\\r\\n      - Upgrade\\r\\n</pre>\\n<p>\\n   All other headers defined by HTTP/1.1 are end-to-end headers.\\r\\n</p>\\n<p>\\n   Other hop-by-hop headers MUST be listed in a Connection header,\\r\\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\\r\\n</p>\\n<h3><a id=\\'sec13.5.2\\'>13.5.2</a> Non-modifiable Headers</h3>\\n<p>\\n   Some features of the HTTP/1.1 protocol, such as Digest\\r\\n   Authentication, depend on the value of certain end-to-end headers. A\\r\\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\\r\\n   definition of that header requires or specifically allows that.\\r\\n</p>\\n<p>\\n   A transparent proxy MUST NOT modify any of the following fields in a\\r\\n   request or response, and it MUST NOT add any of these fields if not\\r\\n   already present:\\r\\n</p>\\n<pre>      - Content-Location\\r\\n</pre>\\n<pre>      - Content-MD5\\r\\n</pre>\\n<pre>      - ETag\\r\\n</pre>\\n<pre>      - Last-Modified\\r\\n</pre>\\n<p>\\n   A transparent proxy MUST NOT modify any of the following fields in a\\r\\n   response:\\r\\n</p>\\n<pre>      - Expires\\r\\n</pre>\\n<p>\\n   but it MAY add any of these fields if not already present. If an\\r\\n   Expires header is added, it MUST be given a field-value identical to\\r\\n   that of the Date header in that response.\\r\\n</p>\\n<p>\\n   A  proxy MUST NOT modify or add any of the following fields in a\\r\\n   message that contains the no-transform cache-control directive, or in\\r\\n   any request:\\r\\n</p>\\n<pre>      - Content-Encoding\\r\\n</pre>\\n<pre>      - Content-Range\\r\\n</pre>\\n<pre>      - Content-Type\\r\\n</pre>\\n<p>\\n   A non-transparent proxy MAY modify or add these fields to a message\\r\\n   that does not include no-transform, but if it does so, it MUST add a\\r\\n   Warning 214 (Transformation applied) if one does not already appear\\r\\n   in the message (see section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.46\\'>14.46</a>).\\r\\n</p>\\n<pre>      Warning: unnecessary modification of end-to-end headers might\\r\\n      cause authentication failures if stronger authentication\\r\\n      mechanisms are introduced in later versions of HTTP. Such\\r\\n      authentication mechanisms MAY rely on the values of header fields\\r\\n      not listed here.\\r\\n</pre>\\n<p>\\n   The Content-Length field of a request or response is added or deleted\\r\\n   according to the rules in section 4.4. A transparent proxy MUST\\r\\n   preserve the entity-length (section <a rel=\\'xref\\' href=\\'rfc2616-sec7.html#sec7.2.2\\'>7.2.2</a>) of the entity-body,\\r\\n   although it MAY change the transfer-length (section <a rel=\\'xref\\' href=\\'rfc2616-sec4.html#sec4.4\\'>4.4</a>).\\r\\n</p>\\n<h3><a id=\\'sec13.5.3\\'>13.5.3</a> Combining Headers</h3>\\n<p>\\n   When a cache makes a validating request to a server, and the server\\r\\n   provides a 304 (Not Modified) response or a 206 (Partial Content)\\r\\n   response, the cache then constructs a response to send to the\\r\\n   requesting client.\\r\\n</p>\\n<p>\\n   If the status code is 304 (Not Modified), the cache uses the entity-\\r\\n   body stored in the cache entry as the entity-body of this outgoing\\r\\n   response. If the status code is 206 (Partial Content) and the ETag or\\r\\n   Last-Modified headers match exactly, the cache MAY combine the\\r\\n   contents stored in the cache entry with the new contents received in\\r\\n   the response and use the result as the entity-body of this outgoing\\r\\n   response, (see <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.5.4\\'>13.5.4</a>).\\r\\n</p>\\n<p>\\n   The end-to-end headers stored in the cache entry are used for the\\r\\n   constructed response, except that\\r\\n</p>\\n<pre>      - any stored Warning headers with warn-code 1xx (see section\\r\\n        <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.46\\'>14.46</a>) MUST be deleted from the cache entry and the forwarded\\r\\n        response.\\r\\n</pre>\\n<pre>      - any stored Warning headers with warn-code 2xx MUST be retained\\r\\n        in the cache entry and the forwarded response.\\r\\n</pre>\\n<pre>      - any end-to-end headers provided in the 304 or 206 response MUST\\r\\n        replace the corresponding headers from the cache entry.\\r\\n</pre>\\n<p>\\n   Unless the cache decides to remove the cache entry, it MUST also\\r\\n   replace the end-to-end headers stored with the cache entry with\\r\\n   corresponding headers received in the incoming response, except for\\r\\n   Warning headers as described immediately above. If a header field-\\r\\n   name in the incoming response matches more than one header in the\\r\\n   cache entry, all such old headers MUST be replaced.\\r\\n</p>\\n<p>\\n   In other words, the set of end-to-end headers received in the\\r\\n   incoming response overrides all corresponding end-to-end headers\\r\\n   stored with the cache entry (except for stored Warning headers with\\r\\n   warn-code 1xx, which are deleted even if not overridden).\\r\\n</p>\\n<pre>      Note: this rule allows an origin server to use a 304 (Not\\r\\n      Modified) or a 206 (Partial Content) response to update any header\\r\\n      associated with a previous response for the same entity or sub-\\r\\n      ranges thereof, although it might not always be meaningful or\\r\\n      correct to do so. This rule does not allow an origin server to use\\r\\n      a 304 (Not Modified) or a 206 (Partial Content) response to\\r\\n      entirely delete a header that it had provided with a previous\\r\\n      response.\\r\\n</pre>\\n<h3><a id=\\'sec13.5.4\\'>13.5.4</a> Combining Byte Ranges</h3>\\n<p>\\n   A response might transfer only a subrange of the bytes of an entity-\\r\\n   body, either because the request included one or more Range\\r\\n   specifications, or because a connection was broken prematurely. After\\r\\n   several such transfers, a cache might have received several ranges of\\r\\n   the same entity-body.\\r\\n</p>\\n<p>\\n   If a cache has a stored non-empty set of subranges for an entity, and\\r\\n   an incoming response transfers another subrange, the cache MAY\\r\\n   combine the new subrange with the existing set if both the following\\r\\n   conditions are met:\\r\\n</p>\\n<pre>      - Both the incoming response and the cache entry have a cache\\r\\n        validator.\\r\\n</pre>\\n<pre>      - The two cache validators match using the strong comparison\\r\\n        function (see section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.3.3\\'>13.3.3</a>).\\r\\n</pre>\\n<p>\\n   If either requirement is not met, the cache MUST use only the most\\r\\n   recent partial response (based on the Date values transmitted with\\r\\n   every response, and using the incoming response if these values are\\r\\n   equal or missing), and MUST discard the other partial information.\\r\\n</p>\\n<h3><a id=\\'sec13.6\\'>13.6</a> Caching Negotiated Responses</h3>\\n<p>\\n   Use of server-driven content negotiation (section <a rel=\\'xref\\' href=\\'rfc2616-sec12.html#sec12.1\\'>12.1</a>), as indicated\\r\\n   by the presence of a Vary header field in a response, alters the\\r\\n   conditions and procedure by which a cache can use the response for\\r\\n   subsequent requests. See section <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.44\\'>14.44</a> for use of the Vary header\\r\\n   field by servers.\\r\\n</p>\\n<p>\\n   A server SHOULD use the Vary header field to inform a cache of what\\r\\n   request-header fields were used to select among multiple\\r\\n   representations of a cacheable response subject to server-driven\\r\\n   negotiation. The set of header fields named by the Vary field value\\r\\n   is known as the \"selecting\" request-headers.\\r\\n</p>\\n<p>\\n   When the cache receives a subsequent request whose Request-URI\\r\\n   specifies one or more cache entries including a Vary header field,\\r\\n   the cache MUST NOT use such a cache entry to construct a response to\\r\\n   the new request unless all of the selecting request-headers present\\r\\n   in the new request match the corresponding stored request-headers in\\r\\n   the original request.\\r\\n</p>\\n<p>\\n   The selecting request-headers from two requests are defined to match\\r\\n   if and only if the selecting request-headers in the first request can\\r\\n   be transformed to the selecting request-headers in the second request\\r\\n</p>\\n<p>\\n   by adding or removing linear white space (LWS) at places where this\\r\\n   is allowed by the corresponding BNF, and/or combining multiple\\r\\n   message-header fields with the same field name following the rules\\r\\n   about message headers in section <a rel=\\'xref\\' href=\\'rfc2616-sec4.html#sec4.2\\'>4.2</a>.\\r\\n</p>\\n<p>\\n   A Vary header field-value of \"*\" always fails to match and subsequent\\r\\n   requests on that resource can only be properly interpreted by the\\r\\n   origin server.\\r\\n</p>\\n<p>\\n   If the selecting request header fields for the cached entry do not\\r\\n   match the selecting request header fields of the new request, then\\r\\n   the cache MUST NOT use a cached entry to satisfy the request unless\\r\\n   it first relays the new request to the origin server in a conditional\\r\\n   request and the server responds with 304 (Not Modified), including an\\r\\n   entity tag or Content-Location that indicates the entity to be used.\\r\\n</p>\\n<p>\\n   If an entity tag was assigned to a cached representation, the\\r\\n   forwarded request SHOULD be conditional and include the entity tags\\r\\n   in an If-None-Match header field from all its cache entries for the\\r\\n   resource. This conveys to the server the set of entities currently\\r\\n   held by the cache, so that if any one of these entities matches the\\r\\n   requested entity, the server can use the ETag header field in its 304\\r\\n   (Not Modified) response to tell the cache which entry is appropriate.\\r\\n   If the entity-tag of the new response matches that of an existing\\r\\n   entry, the new response SHOULD be used to update the header fields of\\r\\n   the existing entry, and the result MUST be returned to the client.\\r\\n</p>\\n<p>\\n   If any of the existing cache entries contains only partial content\\r\\n   for the associated entity, its entity-tag SHOULD NOT be included in\\r\\n   the If-None-Match header field unless the request is for a range that\\r\\n   would be fully satisfied by that entry.\\r\\n</p>\\n<p>\\n   If a cache receives a successful response whose Content-Location\\r\\n   field matches that of an existing cache entry for the same Request-\\r\\n   ]URI, whose entity-tag differs from that of the existing entry, and\\r\\n   whose Date is more recent than that of the existing entry, the\\r\\n   existing entry SHOULD NOT be returned in response to future requests\\r\\n   and SHOULD be deleted from the cache.\\r\\n</p>\\n<h3><a id=\\'sec13.7\\'>13.7</a> Shared and Non-Shared Caches</h3>\\n<p>\\n   For reasons of security and privacy, it is necessary to make a\\r\\n   distinction between \"shared\" and \"non-shared\" caches. A non-shared\\r\\n   cache is one that is accessible only to a single user. Accessibility\\r\\n   in this case SHOULD be enforced by appropriate security mechanisms.\\r\\n   All other caches are considered to be \"shared.\" Other sections of\\r\\n</p>\\n<p>\\n   this specification place certain constraints on the operation of\\r\\n   shared caches in order to prevent loss of privacy or failure of\\r\\n   access controls.\\r\\n</p>\\n<h3><a id=\\'sec13.8\\'>13.8</a> Errors or Incomplete Response Cache Behavior</h3>\\n<p>\\n   A cache that receives an incomplete response (for example, with fewer\\r\\n   bytes of data than specified in a Content-Length header) MAY store\\r\\n   the response. However, the cache MUST treat this as a partial\\r\\n   response. Partial responses MAY be combined as described in section\\r\\n   <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.5.4\\'>13.5.4</a>; the result might be a full response or might still be\\r\\n   partial. A cache MUST NOT return a partial response to a client\\r\\n   without explicitly marking it as such, using the 206 (Partial\\r\\n   Content) status code. A cache MUST NOT return a partial response\\r\\n   using a status code of 200 (OK).\\r\\n</p>\\n<p>\\n   If a cache receives a 5xx response while attempting to revalidate an\\r\\n   entry, it MAY either forward this response to the requesting client,\\r\\n   or act as if the server failed to respond. In the latter case, it MAY\\r\\n   return a previously received response unless the cached entry\\r\\n   includes the \"must-revalidate\" cache-control directive (see section\\r\\n   <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9\\'>14.9</a>).\\r\\n</p>\\n<h3><a id=\\'sec13.9\\'>13.9</a> Side Effects of GET and HEAD</h3>\\n<p>\\n   Unless the origin server explicitly prohibits the caching of their\\r\\n   responses, the application of GET and HEAD methods to any resources\\r\\n   SHOULD NOT have side effects that would lead to erroneous behavior if\\r\\n   these responses are taken from a cache. They MAY still have side\\r\\n   effects, but a cache is not required to consider such side effects in\\r\\n   its caching decisions. Caches are always expected to observe an\\r\\n   origin server\\'s explicit restrictions on caching.\\r\\n</p>\\n<p>\\n   We note one exception to this rule: since some applications have\\r\\n   traditionally used GETs and HEADs with query URLs (those containing a\\r\\n   \"?\" in the rel_path part) to perform operations with significant side\\r\\n   effects, caches MUST NOT treat responses to such URIs as fresh unless\\r\\n   the server provides an explicit expiration time. This specifically\\r\\n   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\\r\\n   be taken from a cache. See section <a rel=\\'xref\\' href=\\'rfc2616-sec9.html#sec9.1.1\\'>9.1.1</a> for related information.\\r\\n</p>\\n<h3><a id=\\'sec13.10\\'>13.10</a> Invalidation After Updates or Deletions</h3>\\n<p>\\n   The effect of certain methods performed on a resource at the origin\\r\\n   server might cause one or more existing cache entries to become non-\\r\\n   transparently invalid. That is, although they might continue to be\\r\\n   \"fresh,\" they do not accurately reflect what the origin server would\\r\\n   return for a new request on that resource.\\r\\n</p>\\n<p>\\n   There is no way for the HTTP protocol to guarantee that all such\\r\\n   cache entries are marked invalid. For example, the request that\\r\\n   caused the change at the origin server might not have gone through\\r\\n   the proxy where a cache entry is stored. However, several rules help\\r\\n   reduce the likelihood of erroneous behavior.\\r\\n</p>\\n<p>\\n   In this section, the phrase \"invalidate an entity\" means that the\\r\\n   cache will either remove all instances of that entity from its\\r\\n   storage, or will mark these as \"invalid\" and in need of a mandatory\\r\\n   revalidation before they can be returned in response to a subsequent\\r\\n   request.\\r\\n</p>\\n<p>\\n   Some HTTP methods MUST cause a cache to invalidate an entity. This is\\r\\n   either the entity referred to by the Request-URI, or by the Location\\r\\n   or Content-Location headers (if present). These methods are:\\r\\n</p>\\n<pre>      - PUT\\r\\n</pre>\\n<pre>      - DELETE\\r\\n</pre>\\n<pre>      - POST\\r\\n</pre>\\n<p>\\n   In order to prevent denial of service attacks, an invalidation based\\r\\n   on the URI in a Location or Content-Location header MUST only be\\r\\n   performed if the host part is the same as in the Request-URI.\\r\\n</p>\\n<p>\\n   A cache that passes through requests for methods it does not\\r\\n   understand SHOULD invalidate any entities referred to by the\\r\\n   Request-URI.\\r\\n</p>\\n<h3><a id=\\'sec13.11\\'>13.11</a> Write-Through Mandatory</h3>\\n<p>\\n   All methods that might be expected to cause modifications to the\\r\\n   origin server\\'s resources MUST be written through to the origin\\r\\n   server. This currently includes all methods except for GET and HEAD.\\r\\n   A cache MUST NOT reply to such a request from a client before having\\r\\n   transmitted the request to the inbound server, and having received a\\r\\n   corresponding response from the inbound server. This does not prevent\\r\\n   a proxy cache from sending a 100 (Continue) response before the\\r\\n   inbound server has sent its final reply.\\r\\n</p>\\n<p>\\n   The alternative (known as \"write-back\" or \"copy-back\" caching) is not\\r\\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\\r\\n   updates and the problems arising from server, cache, or network\\r\\n   failure prior to write-back.\\r\\n</p>\\n<h3><a id=\\'sec13.12\\'>13.12</a> Cache Replacement</h3>\\n<p>\\n   If a new cacheable (see sections <a rel=\\'xref\\' href=\\'rfc2616-sec14.html#sec14.9.2\\'>14.9.2</a>, <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.5\\'>13.2.5</a>, <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.2.6\\'>13.2.6</a> and <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.8\\'>13.8</a>)\\r\\n   response is received from a resource while any existing responses for\\r\\n   the same resource are cached, the cache SHOULD use the new response\\r\\n   to reply to the current request. It MAY insert it into cache storage\\r\\n   and MAY, if it meets all other requirements, use it to respond to any\\r\\n   future requests that would previously have caused the old response to\\r\\n   be returned. If it inserts the new response into cache storage  the\\r\\n   rules in section <a rel=\\'xref\\' href=\\'rfc2616-sec13.html#sec13.5.3\\'>13.5.3</a> apply.\\r\\n</p>\\n<pre>      Note: a new response that has an older Date header value than\\r\\n      existing cached responses is not cacheable.\\r\\n</pre>\\n<h3><a id=\\'sec13.13\\'>13.13</a> History Lists</h3>\\n<p>\\n   User agents often have history mechanisms, such as \"Back\" buttons and\\r\\n   history lists, which can be used to redisplay an entity retrieved\\r\\n   earlier in a session.\\r\\n</p>\\n<p>\\n   History mechanisms and caches are different. In particular history\\r\\n   mechanisms SHOULD NOT try to show a semantically transparent view of\\r\\n   the current state of a resource. Rather, a history mechanism is meant\\r\\n   to show exactly what the user saw at the time when the resource was\\r\\n   retrieved.\\r\\n</p>\\n<p>\\n   By default, an expiration time does not apply to history mechanisms.\\r\\n   If the entity is still in storage, a history mechanism SHOULD display\\r\\n   it even if the entity has expired, unless the user has specifically\\r\\n   configured the agent to refresh expired history documents.\\r\\n</p>\\n<p>\\n   This is not to be construed to prohibit the history mechanism from\\r\\n   telling the user that a view might be stale.\\r\\n</p>\\n<pre>      Note: if history list mechanisms unnecessarily prevent users from\\r\\n      viewing stale resources, this will tend to force service authors\\r\\n      to avoid using HTTP expiration controls and cache controls when\\r\\n      they would otherwise like to. Service authors may consider it\\r\\n      important that users not be presented with error messages or\\r\\n      warning messages when they use navigation controls (such as BACK)\\r\\n      to view previously fetched resources. Even though sometimes such\\r\\n      resources ought not to cached, or ought to expire quickly, user\\r\\n      interface considerations may force service authors to resort to\\r\\n      other means of preventing caching (e.g. \"once-only\" URLs) in order\\r\\n      not to suffer the effects of improperly functioning history\\r\\n      mechanisms.\\r\\n</pre>\\n</body></html>\\n'"}]}